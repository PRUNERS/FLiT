# -- LICENSE BEGIN --
#
# Copyright (c) 2015-2020, Lawrence Livermore National Security, LLC.
#
# Produced at the Lawrence Livermore National Laboratory
#
# Written by
#   Michael Bentley (mikebentley15@gmail.com),
#   Geof Sawaya (fredricflinstone@gmail.com),
#   and Ian Briggs (ian.briggs@utah.edu)
# under the direction of
#   Ganesh Gopalakrishnan
#   and Dong H. Ahn.
#
# LLNL-CODE-743137
#
# All rights reserved.
#
# This file is part of FLiT. For details, see
#   https://pruners.github.io/flit
# Please also read
#   https://github.com/PRUNERS/FLiT/blob/master/LICENSE
#
# Redistribution and use in source and binary forms, with or
# without modification, are permitted provided that the following
# conditions are met:
#
# - Redistributions of source code must retain the above copyright
#   notice, this list of conditions and the disclaimer below.
#
# - Redistributions in binary form must reproduce the above
#   copyright notice, this list of conditions and the disclaimer
#   (as noted below) in the documentation and/or other materials
#   provided with the distribution.
#
# - Neither the name of the LLNS/LLNL nor the names of its
#   contributors may be used to endorse or promote products derived
#   from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
# CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL
# SECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
# TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
# THE POSSIBILITY OF SUCH DAMAGE.
#
# Additional BSD Notice
#
# 1. This notice is required to be provided under our contract
#    with the U.S. Department of Energy (DOE). This work was
#    produced at Lawrence Livermore National Laboratory under
#    Contract No. DE-AC52-07NA27344 with the DOE.
#
# 2. Neither the United States Government nor Lawrence Livermore
#    National Security, LLC nor any of their employees, makes any
#    warranty, express or implied, or assumes any liability or
#    responsibility for the accuracy, completeness, or usefulness of
#    any information, apparatus, product, or process disclosed, or
#    represents that its use would not infringe privately-owned
#    rights.
#
# 3. Also, reference herein to any specific commercial products,
#    process, or services by trade name, trademark, manufacturer or
#    otherwise does not necessarily constitute or imply its
#    endorsement, recommendation, or favoring by the United States
#    Government or Lawrence Livermore National Security, LLC. The
#    views and opinions of authors expressed herein do not
#    necessarily state or reflect those of the United States
#    Government or Lawrence Livermore National Security, LLC, and
#    shall not be used for advertising or product endorsement
#    purposes.
#
# -- LICENSE END --
# Autogenerated Makefile using "flit update"
#   flit version {flit_version}

DEV_TARGET      := devrun
GT_TARGET       := gtrun
GT_OUT          := ground-truth.csv

UNAME_S         := {uname}
HOSTNAME        := {hostname}

# will be None if not specified in flit-config.toml
{compiler_defs}
CLANG_TYPE      := clang
INTEL_TYPE      := intel
GCC_TYPE        := gcc

# keep only the compilers that are not None and are in the path
COMPILERS       := {compilers}
{compiler_fixed_compile_flags}
{compiler_fixed_link_flags}

FLIT_INC_DIR    := {flit_include_dir}
FLIT_SRC_DIR    := {flit_src_dir}
FLIT_SRC        := $(FLIT_SRC_DIR)/ALL-FLIT.cpp
FLIT_DATA_DIR   := {flit_data_dir}
FLIT_SCRIPT_DIR := {flit_script_dir}

DEV_CXX         := {dev_compiler}
DEV_CXX_TYPE    := {dev_type}
DEV_OPTL        := {dev_optl}
DEV_SWITCHES    := {dev_switches}

GT_CXX          := {ground_truth_compiler}
GT_CXX_TYPE     := {ground_truth_type}
GT_OPTL         := {ground_truth_optl}
GT_SWITCHES     := {ground_truth_switches}

TEST_RUN_ARGS   := {test_run_args}
EXTRA_RUN_ARGS  := {extra_run_args}

# initalize some variables to be appended later
CXXFLAGS        :=
LDFLAGS         :=
LDLIBS          :=

GT_CXXFLAGS     := {gt_cxxflags}
GT_LDFLAGS      := {gt_ldflags}
DEV_CXXFLAGS    := {dev_cxxflags}
DEV_LDFLAGS     := {dev_ldflags}

RUNWRAP          = $(RUN_WRAPPER)

ENABLE_MPI      := {enable_mpi}
CXXFLAGS        += {mpi_cxxflags}
LDFLAGS         += {mpi_ldflags}

OBJ_DIR         := obj
DEV_OBJ_DIR     := $(OBJ_DIR)/dev
GT_OBJ_DIR      := $(OBJ_DIR)/gt
RESULTS_DIR     := results
RUNBUILD_DIR    := bin
LOG_DIR         := {log_dir}
LOGFILE_PREFIX  := {logfile}
ALL_DIRS         = $(OBJ_DIR)
ALL_DIRS        += $(DEV_OBJ_DIR)
ALL_DIRS        += $(GT_OBJ_DIR)
ALL_DIRS        += $(RESULTS_DIR)
ALL_DIRS        += $(RUNBUILD_DIR)

# This flag specifies NOT to build position-independent executables
CXXFLAGS        += -fno-pie
CXXFLAGS        += -std=c++11
CXXFLAGS        += -I.
CXXFLAGS        += -I$(FLIT_INC_DIR)

GT_CXXFLAGS     += -g
DEV_CXXFLAGS    += -g
DEV_CXXFLAGS    += -Wall
DEV_CXXFLAGS    += -Wextra
DEV_CXXFLAGS    += -Wuninitialized
DEV_CXXFLAGS    += -Wno-shift-count-overflow

LDLIBS          += -lm
LDLIBS          += -lstdc++

# Be silent by default
ifndef VERBOSE
.SILENT:
endif


# Note: needs dependency out filename after this variable
DEPFLAGS        += -MMD -MP -MF

# TODO: deprecated.  Remove in FLiT version 3.0
TESTS            = $(wildcard tests/*.cpp)
SOURCE           = $(wildcard *.cpp)
SOURCE          += $(TESTS)

# A Makefile function
# @param 1: color (e.g. BLUE or GREEN)
# @param 2: message to be printed in the color
color_out_noline = \
             if [ -t 1 ]; then \
               /bin/echo -ne "$(BASH_$1)$2$(BASH_CLEAR)"; \
             else \
               /bin/echo -n "$2"; \
             fi
color_out = \
             if [ -t 1 ]; then \
               /bin/echo -e "$(BASH_$1)$2$(BASH_CLEAR)"; \
             else \
               /bin/echo "$2"; \
             fi

BASH_CLEAR    := \e[0m
BASH_BLACK    := \e[0;30m
BASH_BROWN    := \e[0;33m
BASH_GRAY     := \e[0;37m
BASH_GREY     := \e[0;37m
BASH_DARKGRAY := \e[1;30m
BASH_DARKGREY := \e[1;30m
BASH_RED      := \e[1;31m
BASH_GREEN    := \e[1;32m
BASH_YELLOW   := \e[1;33m
BASH_BLUE     := \e[1;34m
BASH_PURPLE   := \e[1;35m
BASH_CYAN     := \e[1;36m
BASH_WHITE    := \e[1;37m


.PHONY: help
help:
	@echo 'The following targets are available:'
	@echo
	@echo '  help        Show this help and exit (default target)'
	@echo '  dev         Only run the devel compilation to test things out (devrun)'
	@echo '  dirs        Make only the directories, no files'
	@echo '  gt          Compile the baseline version (gtrun)'
	@echo '  runbuild    Build all executables needed for the run target'
	@echo '  run         Run all combinations of compilation, results in results/'
	@echo '  clean       Clean intermediate files'
	@echo '  veryclean   Runs clean + removes targets and results'
	@echo '  distclean   Same as veryclean'
	@echo

# Note: having this include at the end breaks the makefile for when users add
# to SOURCE from custom.mk
-include custom.mk

# For backward compatability, put old variable names into the standard variable
# locations
# TODO: Remove in FLiT version 3.0
CXXFLAGS        += $(CC_REQUIRED)
LDFLAGS         += $(LD_REQUIRED)
DEV_CXXFLAGS    += $(DEV_CFLAGS)
GT_CXXFLAGS     += $(GT_CFLAGS)

# sort and remove duplicates
# TODO: Remove in FLiT version 3.0
SOURCE          := $(sort $(SOURCE))

# @param 1: directory to create
MKDIR = \
  @$(call color_out,BROWN,  mkdir $@); \
  mkdir -p $@

# individual flags

## optls

{opcodes_definitions}

## switches

{switches_definitions}

{compiler_opcodes}

{compiler_switches}

# Create log directory, and command for writing to log file
# This file is processed with Python strings format() function,
# so bracket escaping is necessary.
comma := ,

ifneq ($(LOG_DIR),)
	# @param 1: Event name
	# @param 2: type (start or stop) of logged event
	# @param 3: properties of event, as list of [ "key": "value"$(comma) ] json items.
	LOG_EVENT = echo '{{"date": "'$$(date)'", "time": '$$(date +%s%N)', "name": "$1", "type": "$2", "properties": {{$3}}}}'
else	
	LOG_EVENT =
endif

# endif

# If LOGFILE is nonempty, enable logging by executing the given make command
# with an additional flag.
ifneq ($(LOGFILE_PREFIX),)

LOGFILE := $(LOG_DIR)/$(LOGFILE_PREFIX)-makelog-$(HOSTNAME)-$$PPID.log

$(LOG_DIR):
	+$(MKDIR) $@

.PHONY: %

# If event logging is enabled, make command is passed through this rule.
# The same make command will be run, with 'output-sync=line' enabled to avoid 
# race conditions when writing the log to file.
#
# All make output will be tee'd into the logfile, and only non-log entries will
# be sent to stdout (determined by whether an output line begins with '{{', as
# current logs are in JSON format.) Logfile will then be rewritten to filter 
# contents to JSON strings only.
# LOGGING=true should be added if above if is in...
%: | $(LOG_DIR)
	@$(MAKE) $@ --output-sync=line LOGFILE_PREFIX="" -f $(firstword $(MAKEFILE_LIST)) \
		| tee -a $(LOGFILE) \
		| grep -v "^\\{{"
	@grep "^\\{{" $(LOGFILE) > tmp.log
	@mv tmp.log $(LOGFILE)

# if logging is turned on, this is the end of the file.
else

.PHONY: recursion-target
REC_MAKE   = $(MAKE) recursion-target --no-print-directory

.PHONY: dev dirs gt gt-fpic runbuild run clean veryclean distclean
dev: $(DEV_TARGET)
dirs:
	+$(REC_MAKE) R_TYPE=dirs
gt: $(GT_TARGET)
gt-fpic: $(RUNBUILD_DIR)/$(GT_TARGET)-fpic
runbuild:
	+$(REC_MAKE) R_TYPE=runbuild
run: runbuild
	+$(REC_MAKE) R_TYPE=run

clean:
	rm -rf $(OBJ_DIR)

veryclean: distclean
distclean: clean
	rm -rf $(RESULTS_DIR)
	rm -rf $(RUNBUILD_DIR)
	rm -f $(DEV_TARGET)
	rm -f $(GT_TARGET)
	rm -f $(GT_OUT)
	rm -f $(addsuffix *.dat,$(GT_OUT))
	rm -rf lib
	rm -rf event_logs

Makefile: flit-config.toml
Makefile: $(FLIT_DATA_DIR)/Makefile.in
Makefile: $(FLIT_SCRIPT_DIR)/flitconfig.py
Makefile: $(FLIT_SCRIPT_DIR)/flitutil.py
Makefile: $(FLIT_SCRIPT_DIR)/flit_update.py
	$(FLIT_SCRIPT_DIR)/flit.py update

# Since this makefile has a huge dependency tree, it was causing the parsing to
# take way too long to generate, especially for small requested tasks.
# Therefore, we split each executable's dependencies into a recursive call on
# this Makefile, setting R_TYPE to compile so that it enumerates the inner
# dependencies of the specified executable (specified in R_TARGET).
#
# This function creates the recursive call for a target.
#
# Note: The target itself should not be phony, otherwise any targets depending
# on $1 would always be rebuilt even if $1 does not need to be.  But, we can
# instead have the $1 target depending on a phony target, then having a no-op
# recipe so that other targets that depend on $1 will recheck the timestamp of
# $1 after the phony target is called.
#
# @param 1: binary compile target
# @param 2: compiler binary
# @param 3: optimization level
# @param 4: switches under test
# @param 5: extra compile flags
# @param 6: link flags
# @param 7: directory for object files
define REC_COMPILE_RULE
ifneq ($$(R_TARGET),$1)
$1: $1-phony
	@true

.PHONY: $1-phony
$1-phony: Makefile custom.mk
	+$$(REC_MAKE) R_TYPE=compile \
	  R_TARGET="$1" \
	  R_COMPILER="$2" \
	  R_OPTL="$3" \
	  R_SWITCHES="$4" \
	  R_CXXFLAGS="$5" \
	  R_LDFLAGS="$6" \
	  R_OBJ_DIR="$7"
endif
endef

#
# Here I define three targets: gt, dev, and gt-fpic
# - They are surrounded in the ifneq tags because if not, they would have two
#   definitions for that target.  Also, from some recursion compile targets, we
#   need access to know how to compile the $(GT_TARGET) for the runbuild.
#

$(eval $(call REC_COMPILE_RULE,\
  $(RUNBUILD_DIR)/$(GT_TARGET)-fpic,\
  $(GT_CXX),\
  $(GT_OPTL),\
  $(GT_SWITCHES),\
  $(GT_CXXFLAGS) -fPIC,\
  $(GT_LDFLAGS),\
  $(GT_OBJ_DIR)-fpic))

$(eval $(call REC_COMPILE_RULE,\
  $(DEV_TARGET),\
  $(DEV_CXX),\
  $(DEV_OPTL),\
  $(DEV_SWITCHES),\
  $(DEV_CXXFLAGS),\
  $(DEV_LDFLAGS),\
  $(DEV_OBJ_DIR)))

$(eval $(call REC_COMPILE_RULE,\
  $(GT_TARGET),\
  $(GT_CXX),\
  $(GT_OPTL),\
  $(GT_SWITCHES),\
  $(GT_CXXFLAGS),\
  $(GT_LDFLAGS),\
  $(GT_OBJ_DIR)))

$(GT_OUT): $(GT_TARGET)
	@$(call color_out,CYAN,  $< -> $@)
	@$(call LOG_EVENT,Make Run Tests Baseline,start,"File": "$(GT_TARGET)"$(comma) \
		"Output": "$(GT_OUT)"$(comma) "Compilation": "$(GT_TARGET)")
	$(RUNWRAP) ./$(GT_TARGET) $(EXTRA_RUN_ARGS) --output $(GT_OUT) --no-timing
	@$(call LOG_EVENT,Make Run Tests Baseline,stop,"File": "$(GT_TARGET)"$(comma) \
		"Output": "$(GT_OUT)"$(comma) "Compilation": "$(GT_TARGET)")

#
# Enter the recursion types
#


#######################
# *** R_TYPE=dirs *** #
#######################

ifeq ($(R_TYPE),dirs)

ALL_DIRS += $(foreach c,$(COMPILERS),\
              $(foreach s,$(SWITCHES_$(strip $c)),\
                $(foreach o,$(OPCODES_$(strip $c)),\
                  $(OBJ_DIR)/$c_$s_$o)))

recursion-target: $(ALL_DIRS)

$(ALL_DIRS):
	+$(MKDIR) $@


###########################
# *** R_TYPE=runbuild *** #
###########################

else ifeq ($(R_TYPE),runbuild)

# @param 1: compiler variable name
# @param 2: switches variable name
# @param 3: optl variable name
define RUNBUILD_REC_RULE
recursion-target: $(RUNBUILD_DIR)/$1_$2_$3
$(eval $(call REC_COMPILE_RULE,\
  $(RUNBUILD_DIR)/$1_$2_$3,\
  $($1),\
  $($3),\
  $($2),\
  $($1_CXXFLAGS),\
  $($1_LDFLAGS),\
  $(OBJ_DIR)/$1_$2_$3))
endef

$(foreach c,$(COMPILERS),\
  $(foreach s,$(SWITCHES_$(strip $c)),\
    $(foreach o,$(OPCODES_$(strip $c)),\
      $(eval $(call RUNBUILD_REC_RULE,$(strip $c),$(strip $s),$(strip $o))))))

recursion-target: $(GT_TARGET)


######################
# *** R_TYPE=run *** #
######################

else ifeq ($(R_TYPE),run)

ALL_RESULTS := $(foreach c,$(COMPILERS),\
                 $(foreach s,$(SWITCHES_$(strip $c)),\
                   $(foreach o,$(OPCODES_$(strip $c)),\
                     $(RESULTS_DIR)/$c_$s_$o-out-comparison.csv)))

recursion-target: $(ALL_RESULTS)

$(RESULTS_DIR)/%-out: $(RUNBUILD_DIR)/% | $(RESULTS_DIR)
	@$(call color_out,CYAN,  $< -> $@)
	@$(call LOG_EVENT,Make Run Tests,start,"File": "$<"$(comma) "Args": "$(TEST_RUN_ARGS)"$(comma) \
		"Output": "$@"$(comma) "Compilation": "$*")
	$(RUNWRAP) ./$< $(EXTRA_RUN_ARGS) $(TEST_RUN_ARGS) --output $@ || touch $@
	@$(call LOG_EVENT,Make Run Tests,stop,"File": "$<"$(comma) "Args": "$(TEST_RUN_ARGS)"$(comma) \
		"Output": "$@"$(comma) "Compilation": "$*")

%-out-comparison.csv: %-out $(GT_TARGET) $(GT_OUT)
	@$(call color_out,CYAN,  $< -> $@)
	@$(call LOG_EVENT,Make Compare Tests,start,"File": "$(GT_TARGET)"$(comma) "Output": "$(GT_OUT)"$(comma) \
		"Compilation": "$(notdir $*)"$(comma) "Test Result": "$(notdir $*)-out")
	$(RUNWRAP) ./$(GT_TARGET) $(EXTRA_RUN_ARGS) --compare-mode --compare-gt $(GT_OUT) --suffix "-comparison.csv" $< -o /dev/null
	@$(call LOG_EVENT,Make Compare Tests,stop,"File": "$(GT_TARGET)"$(comma) "Output": "$(GT_OUT)"$(comma) \
		"Compilation": "$(notdir $*)"$(comma) "Test Result": "$(notdir $*)-out")

$(RESULTS_DIR):
	+$(MKDIR) $@



##########################
# *** R_TYPE=compile *** #
##########################

else ifeq ($(R_TYPE),compile)

# Compiles a single object file from a source file given compiler and flags
# @param 1: source file
# @param 2: object file
# @param 3: compiler
# @param 4: optimization level
# @param 5: switches under consideration
# @param 6: target filename
# @param 7: extra compiler flags
define COMPILE_RULE
$2: $1 Makefile custom.mk | $(patsubst %/,%,$(dir $2))
	@$(call color_out,CYAN,  $(strip $1) -> $(strip $2))
	@# Log object file
	@$$(call LOG_EVENT,Compile,start,"File": "$$(strip $1)"$$(comma) "Object File": "$$(strip $2)"$$(comma)\
		"Compiler": "$$(strip $3)"$$(comma) "Switches": "$$(strip $5)"$$(comma) "Optl":"$$(strip $4)")
	$3 $4 $5 -c $(CXXFLAGS) $(DEPFLAGS) $(2:%.o=%.d) $7 $1 -o $2 \
	  -DFLIT_HOST='"$(HOSTNAME)"' \
	  -DFLIT_COMPILER='"$(strip $3)"' \
	  -DFLIT_OPTL='"$(strip $4)"' \
	  -DFLIT_SWITCHES='"$(strip $5)"' \
	  -DFLIT_FILENAME='"$(notdir $(strip $6))"'
	@$$(call LOG_EVENT,Compile,stop,"File": "$$(strip $1)"$$(comma) "Object File": "$$(strip $2)"$$(comma)\
		"Compiler": "$$(strip $3)"$$(comma) "Switches": "$$(strip $5)"$$(comma) "Optl":"$$(strip $4)")
endef

R_OBJ   := $(addprefix $(R_OBJ_DIR)/,$(notdir $(SOURCE:%=%.o)))
R_OBJ   += $(addprefix $(R_OBJ_DIR)/,$(notdir $(FLIT_SRC:%=%.o)))
R_DEP   := $(R_OBJ:%.o=%.d)

-include $(R_DEP)

recursion-target: $(R_TARGET)

# By giving "phony-%" as the value to R_TARGET, we only create the object files
ifeq ($(patsubst phony-%,phony,$(R_TARGET)),phony)
$(R_TARGET): $(R_OBJ)
else
$(R_TARGET): $(R_OBJ)
	@$(call color_out,BLUE,  Creating $(R_TARGET))
	@$(call LOG_EVENT,Linking,start,"File": "$@"$(comma) "Files In": "$(R_OBJ)"$(comma) \
	  "Compiler": "$(R_COMPILER)"$(comma) "Optl": "$(R_OPTL)"$(comma) \
	  "Switches": "$(R_SWITCHES)"$(comma) "LDLibs": "$(LDLIBS)"$(comma) \
	  "CXXFLAGS": "$(R_CXXFLAGS) $(CXXFLAGS)"$(comma) \
	  "LDFLAGS": "$(LDFLAGS) $(R_LDFLAGS)"$(comma) \
	  "Compilation": "$(notdir $(R_TARGET))")
	@+mkdir -p $(dir $@)
	$(R_COMPILER) -o $@ $(R_OPTL) $(R_SWITCHES) $(R_CXXFLAGS) $(CXXFLAGS) \
	  $(R_OBJ) $(LDFLAGS) $(R_LDFLAGS) $(LDLIBS)
	@$(call LOG_EVENT,Linking,stop,"File": "$@"$(comma) "Files In": "$(R_OBJ)"$(comma) \
	  "Compiler": "$(R_COMPILER)"$(comma) "Optl": "$(R_OPTL)"$(comma) \
	  "Switches": "$(R_SWITCHES)"$(comma) "LDLibs": "$(LDLIBS)"$(comma) \
	  "CXXFLAGS": "$(R_CXXFLAGS) $(CXXFLAGS)"$(comma) \
	  "LDFLAGS": "$(LDFLAGS) $(R_LDFLAGS)"$(comma) \
	  "Compilation": "$(notdir $(R_TARGET))")
endif

$(R_OBJ_DIR):
	+$(MKDIR) $@

$(foreach s,$(SOURCE) $(FLIT_SRC), \
  $(eval $(call COMPILE_RULE,\
    $s,\
    $(R_OBJ_DIR)/$(notdir $s).o,\
    $(R_COMPILER),\
    $(R_OPTL),\
    $(R_SWITCHES),\
    $(R_TARGET),\
    $(R_CXXFLAGS))))

endif # end of R_TYPE chain
endif # end of output-sync pass
