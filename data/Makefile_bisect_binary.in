# -- LICENSE BEGIN --
#
# Copyright (c) 2015-2020, Lawrence Livermore National Security, LLC.
#
# Produced at the Lawrence Livermore National Laboratory
#
# Written by
#   Michael Bentley (mikebentley15@gmail.com),
#   Geof Sawaya (fredricflinstone@gmail.com),
#   and Ian Briggs (ian.briggs@utah.edu)
# under the direction of
#   Ganesh Gopalakrishnan
#   and Dong H. Ahn.
#
# LLNL-CODE-743137
#
# All rights reserved.
#
# This file is part of FLiT. For details, see
#   https://pruners.github.io/flit
# Please also read
#   https://github.com/PRUNERS/FLiT/blob/master/LICENSE
#
# Redistribution and use in source and binary forms, with or
# without modification, are permitted provided that the following
# conditions are met:
#
# - Redistributions of source code must retain the above copyright
#   notice, this list of conditions and the disclaimer below.
#
# - Redistributions in binary form must reproduce the above
#   copyright notice, this list of conditions and the disclaimer
#   (as noted below) in the documentation and/or other materials
#   provided with the distribution.
#
# - Neither the name of the LLNS/LLNL nor the names of its
#   contributors may be used to endorse or promote products derived
#   from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
# CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL
# SECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
# TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
# THE POSSIBILITY OF SUCH DAMAGE.
#
# Additional BSD Notice
#
# 1. This notice is required to be provided under our contract
#    with the U.S. Department of Energy (DOE). This work was
#    produced at Lawrence Livermore National Laboratory under
#    Contract No. DE-AC52-07NA27344 with the DOE.
#
# 2. Neither the United States Government nor Lawrence Livermore
#    National Security, LLC nor any of their employees, makes any
#    warranty, express or implied, or assumes any liability or
#    responsibility for the accuracy, completeness, or usefulness of
#    any information, apparatus, product, or process disclosed, or
#    represents that its use would not infringe privately-owned
#    rights.
#
# 3. Also, reference herein to any specific commercial products,
#    process, or services by trade name, trademark, manufacturer or
#    otherwise does not necessarily constitute or imply its
#    endorsement, recommendation, or favoring by the United States
#    Government or Lawrence Livermore National Security, LLC. The
#    views and opinions of authors expressed herein do not
#    necessarily state or reflect those of the United States
#    Government or Lawrence Livermore National Security, LLC, and
#    shall not be used for advertising or product endorsement
#    purposes.
#
# -- LICENSE END --

# Autogenerated Makefile using "flit bisect"
#   Date:         {datetime}
#   FLiT version: {flit_version}
#
# This file is intended to test one combination of compiling between a
# troublesome compilation and the ground truth compilation.
#
# For every combination that needs to be tested, a new Makefile is generated

# include the main Makefiles for this project, getting their juicy settings
# Note: Makefile already includes custom.mk, so we don't need to explicitly
#       include it here.
-include Makefile
	
PRECISION        := {precision}
TEST_CASE        := {test_case}

TROUBLE_CXX      := {trouble_cxx}
TROUBLE_OPTL     := {trouble_optl}
TROUBLE_SWITCHES := {trouble_switches}
TROUBLE_CXX_TYPE := {trouble_type}
BISECT_LINK      := {bisect_linker}
RM               := rm -f
RMDIR            := rm -rf

TROUBLE_ID       := {trouble_id}

MAKEFILE         := {makefile}
NUMBER           := {number}
BISECT_DIR       := {bisect_dir}
LOCAL_OBJ_DIR    := $(BISECT_DIR)/obj
FPIC_DIR         := $(LOCAL_OBJ_DIR)/fpic
SPLIT_DIR        := $(LOCAL_OBJ_DIR)/split
SYMBOLS_DIR      := $(LOCAL_OBJ_DIR)/symbols

BISECT_OBJ_DIR   := $(OBJ_DIR)/bisect/$(TROUBLE_ID)
MORE_DIRS        += $(BISECT_DIR)
MORE_DIRS        += $(LOCAL_OBJ_DIR)/trouble
MORE_DIRS        += $(LOCAL_OBJ_DIR)/gt
MORE_DIRS        += $(FPIC_DIR)/trouble
MORE_DIRS        += $(FPIC_DIR)/gt
MORE_DIRS        += $(SPLIT_DIR)
MORE_DIRS        += $(SYMBOLS_DIR)
BISECT_TARGET    := $(BISECT_DIR)/runbisect-$(NUMBER)
TROUBLE_TARGET   := $(BISECT_DIR)/runtrouble-$(NUMBER)

BISECT_GT_SRC    :=
{BISECT_GT_SRC}

TROUBLE_SRC      :=
{TROUBLE_SRC}

SPLIT_SRC        :=
{SPLIT_SRC}

# Add to the LDFLAGS if necessary
{EXTRA_LDFLAGS}

TROUBLE_CXXFLAGS := {trouble_cxxflags}
TROUBLE_LDFLAGS  := {trouble_ldflags}
BISECT_LDFLAGS   := {bisect_ldflags}

TROUBLE_TARGET_OUT := $(TROUBLE_TARGET:%=%-out)
TROUBLE_TARGET_RESULT := $(TROUBLE_TARGET_OUT:%=%-comparison.csv)
BISECT_OUT         := $(BISECT_TARGET:%=%-out)
BISECT_RESULT      := $(BISECT_OUT:%=%-comparison.csv)

# make recursive calls use this makefile
REC_MAKE           += -f $(MAKEFILE)

BUILD_GT_LOCAL   := {build_gt_local}
GT_LIB_TARGET    := $(BISECT_DIR)/gtrun-lib
GT_LIB_OUT       := $(BISECT_DIR)/gtrun-lib.csv

ifeq ($(BUILD_GT_LOCAL),true)
  GT_RESULT_TO_USE  := $(GT_LIB_OUT)
  GT_TARGET_TO_USE  := $(GT_LIB_TARGET)
else
  GT_RESULT_TO_USE  := $(GT_OUT)
  GT_TARGET_TO_USE  := $(GT_TARGET)
endif

# If logging is enabled, base Makefile needs
# to recall make command and sets LOGFILE_PREFIX
# to blank; so skip this until it is blank.
# See base FLiT Makefile for more info.
ifeq ($(LOGFILE_PREFIX),)

.PHONY: bisect
bisect: $(BISECT_TARGET) $(BISECT_RESULT)

.PHONY: bisect-smallclean bisect-clean bisect-distclean
clean: bisect-clean
distclean: bisect-distclean
bisect-smallclean:
	$(RM) $(BISECT_TARGET)
	$(RM) $(BISECT_OUT)
	$(RM) $(addsuffix *.dat,$(BISECT_OUT))
	$(RMDIR) $(SPLIT_DIR)

bisect-clean: bisect-smallclean
	$(RM) $(GT_LIB_TARGET)
	$(RM) $(GT_LIB_OUT)
	$(RM) $(addsuffix *.dat,$(GT_LIB_OUT))
	$(RMDIR) $(FPIC_DIR)
	$(RMDIR) $(BISECT_OBJ_DIR)
	$(RMDIR) $(LOCAL_OBJ_DIR)/trouble

bisect-distclean: bisect-clean
	$(RM) bisect.log
	$(RM) $(BISECT_RESULT)
	$(RM) $(MAKEFILE)
	$(RMDIR) $(SYMBOLS_DIR)
	$(RMDIR) $(LOCAL_OBJ_DIR)
	-rmdir --ignore-fail-on-non-empty $(BISECT_DIR)

.PHONY: trouble phony-trouble
trouble: phony-trouble
# Note: phony-target here causes no executable to be created
$(eval $(call REC_COMPILE_RULE,\
  phony-trouble,\
  $(TROUBLE_CXX),\
  $(TROUBLE_OPTL),\
  $(TROUBLE_SWITCHES),\
  $(TROUBLE_CXXFLAGS),\
  $(TROUBLE_LDFLAGS),\
  $(BISECT_OBJ_DIR)))

# to create the fpic version of the object files
.PHONY: trouble-fpic phony-trouble-fpic
trouble-fpic: phony-trouble-fpic
# Note: phony-target here causes no executable to be created
$(eval $(call REC_COMPILE_RULE,\
  phony-trouble-fpic,\
  $(TROUBLE_CXX),\
  $(TROUBLE_OPTL),\
  $(TROUBLE_SWITCHES),\
  $(TROUBLE_CXXFLAGS) -fPIC,\
  $(TROUBLE_LDFLAGS),\
  $(BISECT_OBJ_DIR)/fpic))

# Note: this differs from GT_TARGET because LDFLAGS was changed above
$(GT_LIB_TARGET): $(LIBFLIT)
$(eval $(call REC_COMPILE_RULE,\
  $(GT_LIB_TARGET),\
  $(GT_CXX),\
  $(GT_OPTL),\
  $(GT_SWITCHES),\
  $(GT_CXXFLAGS),\
  $(GT_LDFLAGS),\
  $(GT_OBJ_DIR)))

$(MORE_DIRS):
	+$(MKDIR) $@

# rule guarded because the bisect-compile section redefines $(BISECT_TARGET)
ifndef R_TYPE
.PHONY: $(BISECT_TARGET)
$(BISECT_TARGET):
	+$(REC_MAKE) R_TYPE=bisect-compile
endif

$(GT_LIB_OUT): $(GT_LIB_TARGET) | $(BISECT_DIR)
	@$(call color_out,CYAN,  $< -> $@)
	@$(call LOG_EVENT,Bisect Run Tests Baseline Lib,start,"File": "$(GT_LIB_TARGET)"$(comma) "Output": "$@" )
	$(RUNWRAP) ./$(GT_LIB_TARGET) $(EXTRA_RUN_ARGS) --output $(GT_LIB_OUT) --no-timing \
	  --precision "$(PRECISION)" $(TEST_CASE)
	@$(call LOG_EVENT,Bisect Run Tests Baseline Lib,stop,"File": "$(GT_LIB_TARGET)"$(comma) "Output": "$@" )

$(BISECT_OUT): $(BISECT_TARGET) | $(BISECT_DIR)
	@$(call color_out,CYAN,  $< -> $@)
	@$(call LOG_EVENT,Make Bisect Run Tests,start,"File": "$(BISECT_TARGET)"$(comma) "Output": "$@" )
	$(RUNWRAP) ./$< $(EXTRA_RUN_ARGS) --precision "$(PRECISION)" --output $@ $(TEST_CASE) --no-timing
	@$(call LOG_EVENT,Make Bisect Run Tests,stop,"File": "$(BISECT_TARGET)"$(comma) "Output": "$@" )

$(BISECT_RESULT): $(BISECT_OUT) $(GT_RESULT_TO_USE) $(GT_TARGET_TO_USE)
	@$(call color_out,CYAN,  $< -> $@)
	@$(call LOG_EVENT,Make Bisect Compare Tests,start,"File": "$(GT_TARGET_TO_USE)"$(comma) \
		"Results Compared": "$(GT_RESULT_TO_USE)"$(comma) "Output": "$@" )
	$(RUNWRAP) ./$(GT_TARGET_TO_USE) $(EXTRA_RUN_ARGS) --compare-mode --compare-gt $(GT_RESULT_TO_USE) \
	  --suffix "-comparison.csv" $< -o /dev/null
	@$(call LOG_EVENT,Make Bisect Compare Tests,stop,"File": "$(GT_TARGET_TO_USE)"$(comma) \
		"Results Compared": "$(GT_RESULT_TO_USE)"$(comma) "Output": "$@" )

#################################
# *** R_TYPE=bisect-compile *** #
#################################

ifeq ($(R_TYPE),bisect-compile)

BISECT_GT_OBJ    := $(addprefix \
    $(GT_OBJ_DIR)/,$(notdir $(BISECT_GT_SRC:%=%.o)))
TROUBLE_OBJ      := $(addprefix \
    $(LOCAL_OBJ_DIR)/trouble/,$(notdir $(TROUBLE_SRC:%=%.o)))
SPLIT_OBJ        := $(addprefix \
    $(SPLIT_DIR)/,$(notdir $(SPLIT_SRC:%=%_gt_split_$(NUMBER).o)))
SPLIT_OBJ        += $(addprefix \
    $(SPLIT_DIR)/,$(notdir \
      $(SPLIT_SRC:%=%_trouble_split_$(NUMBER).o)))
BISECT_OBJ       := $(BISECT_GT_OBJ)
BISECT_OBJ       += $(GT_OBJ_DIR)/ALL-FLIT.cpp.o
BISECT_OBJ       += $(TROUBLE_OBJ)
BISECT_OBJ       += $(SPLIT_OBJ)
BISECT_DEP       := $(BISECT_OBJ:%.o=%.d)


-include $(BISECT_DEP)

recursion-target: $(BISECT_TARGET)

$(BISECT_TARGET): $(BISECT_OBJ) Makefile custom.mk | $(BISECT_DIR)
	@$(call color_out,BLUE,  Creating $@)
	@$(call LOG_EVENT,Bisect Link,start,"File": "$@"$(comma) "Files In": "$(BISECT_OBJ)"$(comma) \
	  "Linker": "$(BISECT_LINK)"$(comma) "LDFlags": "$(LDFLAGS) $(BISECT_LDFLAGS)"$(comma) \
	  "LDLibs": "$(LDLIBS)"$(comma) "CXXFlags": "$(CXXFLAGS) $(GT_CXXFLAGS)")
	$(BISECT_LINK) $(CXXFLAGS) $(GT_CXXFLAGS) -o $@ $(BISECT_OBJ) $(LDFLAGS) \
	  $(BISECT_LDFLAGS) $(LDLIBS)
	@$(call LOG_EVENT,Bisect Link,stop,"File": "$@"$(comma) "Files In": "$(BISECT_OBJ)"$(comma) \
	  "Linker": "$(BISECT_LINK)"$(comma) "LDFlags": "$(LDFLAGS) $(BISECT_LDFLAGS)"$(comma) \
	  "LDLibs": "$(LDLIBS)"$(comma) "CXXFlags": "$(CXXFLAGS) $(GT_CXXFLAGS)")

# compile BISECT_GT_OBJ
$(foreach s,$(BISECT_GT_SRC),\
  $(eval $(call COMPILE_RULE,\
    $s,\
    $(GT_OBJ_DIR)/$(notdir $s).o,\
    $(GT_CXX),\
    $(GT_OPTL),\
    $(GT_SWITCHES),\
    $(notdir $(BISECT_TARGET)),\
    $(GT_CXXFLAGS))))

# Similar to COMPILE_RULE in Makefile but has an extra param
# @param 8: directory where a copy may reside.  If this directory has the
#   desired object file, then copy it instead of compiling one
#
# TODO: Could capture "compile" or "copy" property, but may need to move conditional to make. 
#       Probably not necessary...
define COMPILE_OR_COPY_RULE
$2: $1 Makefile custom.mk | $(patsubst %/,%,$(dir $2))
	@$(call LOG_EVENT,Bisect Compile,start,"File": "$(strip $1)"$(comma) "Object File": "$(strip $2)"$(comma)\
		"Compiler": "$(strip $3)"$(comma) "Switches": "$(strip $5)"$(comma) "Optl":"$(strip $4)")
	if [ -f "$(strip $8)/$(notdir $2)" ]; then \
	  $(call color_out,CYAN,  $8/$(notdir $2) -> $2); \
	  ln -s $$(shell realpath --relative-to $(dir $2) $(strip $8)/$(notdir $2)) $2; \
	else \
	  $(call color_out,CYAN,  $1 -> $2); \
	  $3 $4 $5 -c $(CXXFLAGS) $(DEPFLAGS) $(2:%.o=%.d) $7 $1 -o $2 \
	    -DFLIT_HOST='"$(HOSTNAME)"' \
	    -DFLIT_COMPILER='"$(strip $3)"' \
	    -DFLIT_OPTL='"$(strip $4)"' \
	    -DFLIT_SWITCHES='"$(strip $5)"' \
	    -DFLIT_FILENAME='"$(notdir $(strip $6))"'; \
	fi
	@$(call LOG_EVENT,Bisect Compile,stop,"File": "$(strip $1)"$(comma) "Object File": "$(strip $2)"$(comma)\
		"Compiler": "$(strip $3)"$(comma) "Switches": "$(strip $5)"$(comma) "Optl":"$(strip $4)")
endef

# compile TROUBLE_OBJ
$(foreach s,$(TROUBLE_SRC),\
  $(eval $(call COMPILE_OR_COPY_RULE,\
    $s,\
    $(LOCAL_OBJ_DIR)/trouble/$(notdir $s).o,\
    $(TROUBLE_CXX),\
    $(TROUBLE_OPTL),\
    $(TROUBLE_SWITCHES),\
    $(notdir $(BISECT_TARGET)),\
    $(TROUBLE_CXXFLAGS),\
    $(BISECT_OBJ_DIR))))

# compile GT fPIC object files
$(foreach s,$(SPLIT_SRC) $(FLIT_SRC),\
  $(eval $(call COMPILE_OR_COPY_RULE,\
    $s,\
    $(FPIC_DIR)/gt/$(notdir $s).o,\
    $(GT_CXX),\
    $(GT_OPTL),\
    $(GT_SWITCHES),\
    $(notdir $(BISECT_TARGET)),\
    $(GT_CXXFLAGS) -fPIC,\
    $(GT_OBJ_DIR)-fpic)))

# compile trouble fPIC object files
$(foreach s,$(SPLIT_SRC),\
  $(eval $(call COMPILE_OR_COPY_RULE,\
    $s,\
    $(FPIC_DIR)/trouble/$(notdir $s).o,\
    $(TROUBLE_CXX),\
    $(TROUBLE_OPTL),\
    $(TROUBLE_SWITCHES),\
    $(notdir $(BISECT_TARGET)),\
    $(TROUBLE_CXXFLAGS) -fPIC,\
    $(BISECT_OBJ_DIR)/fpic)))

# Defines how to copy a given object file weakening certain symbols in the copy
# @param 1: source object file
# @param 2: destination object file (e.g., the copy to make)
# @param 3: file containing symbols to weaken
define WEAKENED_COPY_RULE
$2: $1 $3 $$(MAKEFILE) | $(patsubst %/,%,$(dir $2))
	@$(call color_out,CYAN,  $1 -> $2)
	@$(call LOG_EVENT,Weaken Symbols,start,"File": "$2"$(comma) "Source File": "$1"$(comma) "Symbols File": "$3")
	if [ -s "$(strip $3)" ]; then \
	  objcopy --weaken-symbols="$(strip $3)" $1 $2; \
	else \
	  cp $1 $2; \
	fi
	@$(call LOG_EVENT,Weaken Symbols,stop,"File": "$2"$(comma) "Source File": "$1"$(comma) "Symbols File": "$3")
endef

# weakened gt object files
$(foreach s,$(SPLIT_SRC),\
  $(eval $(call WEAKENED_COPY_RULE,\
    $(FPIC_DIR)/gt/$(notdir $s).o,\
    $(SPLIT_DIR)/$(notdir $s)_gt_split_$(NUMBER).o,\
    $(SYMBOLS_DIR)/$(notdir $s)_trouble_symbols_$(NUMBER).txt)))

# weakened trouble object files
$(foreach s,$(SPLIT_SRC),\
  $(eval $(call WEAKENED_COPY_RULE,\
    $(FPIC_DIR)/trouble/$(notdir $s).o,\
    $(SPLIT_DIR)/$(notdir $s)_trouble_split_$(NUMBER).o,\
    $(SYMBOLS_DIR)/$(notdir $s)_gt_symbols_$(NUMBER).txt)))

endif # of ifeq ($(R_TYPE),bisect-compile)
endif # of ifeq ($(LOGFILE_PREFIX),)
